plugins { id "com.jfrog.bintray" version "1.7" }

import org.apache.tools.ant.taskdefs.condition.Os


apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'maven'
apply plugin: 'maven-publish'

version = '0.1.0'

def project_root = file(".").absolutePath
def native_build_dir = './build/cpp'
def native_source_dir = './src/cpp'
def native_static_lib = ""
def native_shared_lib = ""

def jnaerator_plat_path = {

  def is_64 = (System.getProperty("os.arch").indexOf("64") != -1)
  def plat_path = ""
  
  if (Os.isFamily(Os.FAMILY_WINDOWS)) {
    if(is_64){
      plat_path = "win64"
    }
    else{
      plat_path = "win32"
    }
  }
  else if (Os.isFamily(Os.FAMILY_MAC)) {
      plat_path = "darwin_universal"
 }
else if (Os.isFamily(Os.FAMILY_UNIX)) {
    if(is_64){
      plat_path = "linux_x64"
    }
    else{
      plat_path = "linux_x86"
    }
}

}

task create_build_dir << {
  println 'create_build_dir'
  new File(native_build_dir).mkdirs()
}


// cmake task:
task cmake(type:Exec) {
  
  workingDir native_build_dir
  
  inputs.dir file(native_source_dir).absolutePath
  
  if (Os.isFamily(Os.FAMILY_WINDOWS)){
  outputs.files file(native_build_dir).absolutePath + '\\ALL_BUILD.vcxproj', file(native_build_dir).absolutePath + '\\CMakeCache.txt'
  } else {
  outputs.files file(native_build_dir).absolutePath + '/Makefile', file(native_build_dir).absolutePath + '/CMakeCache.txt'
}
  def native_build_type = project.hasProperty("sqy_build_type") ? sqy_build_type : "Release"
  def sqy_x = project.hasProperty("sqy_experimental") ? sqy_experimental : "0"
  def path_to_lz4 = project.hasProperty("lz4_path") ? lz4_path : ""
  def path_to_ffmpeg = project.hasProperty("ffmpeg_path") ? ffmpeg_path : ""
  def path_to_hdf5 = project.hasProperty("hdf5_path") ? hdf5_path : ""
  def path_to_tiff = project.hasProperty("tiff_path") ? tiff_path : ""	
  def path_to_boost = project.hasProperty("boost_path") ? boost_path : ""
  def path_to_cmake_app = project.hasProperty("cmake_app_path") ? cmake_app_path : "cmake"
  
  
  //DEFINE DEFAULTS
  if (Os.isFamily(Os.FAMILY_WINDOWS)){
    
	path_to_cmake_app = project.hasProperty("cmake_app_path") ? cmake_app_path : "cmake.exe"
    executable path_to_cmake_app
	
	if(System.getProperty("os.arch").indexOf("64") != -1){
		args "-Ax64"
	} //args "-G \"Visual Studio 14 2015 Win64\""
	
	
	
	//args "-DCMAKE_BINARY_DIR="+file(native_build_dir).absolutePath
  } 
  else if (Os.isFamily(Os.FAMILY_MAC))
  {
    executable path_to_cmake_app
    
  } 
  else if (Os.isFamily(Os.FAMILY_UNIX))
  {
    executable path_to_cmake_app
    
  }
	

  args "-DCMAKE_BUILD_TYPE="+native_build_type
  
  if(sqy_x != "0"){
    args "-DSQY_EXPERIMENTAL=ON"
  }
    
  if(path_to_lz4){
    
    args "-DLZ4_ROOT=" + path_to_lz4
  }

  if(path_to_ffmpeg){
    //TODO: see if path exists
    args "-DFFMPEG_ROOT=" + path_to_ffmpeg
  }

  
  if(path_to_hdf5){
    //TODO: see if path exists
    args "-DHDF5_ROOT=" + path_to_hdf5
  }

  if(path_to_tiff){
    //TODO: see if path exists
    args "-DTIFF_ROOT=" + path_to_tiff 
	/* if (Os.isFamily(Os.FAMILY_WINDOWS)){
		def tiff_path = file(path_to_tiff).absolutePath
		def tiff_include = tiff_path + "\\include"
		def tiff_lib = tiff_path + "\\lib\\libtiff.dll"
		args "-DTIFF_INCLUDE_DIR="+ tiff_include
		args "-DTIFF_LIBRARY="+ tiff_lib
	} else {
		args "-DTIFF_INCLUDE_DIR="+ path_to_tiff +"/include"
		args "-DTIFF_LIBRARY="+ path_to_tiff +"/lib/libtiff.so"
	} */
  }

  if(path_to_boost){
    //TODO: see if path exists
    args "-DBOOST_ROOT=" + path_to_boost 
  }

  
	args file(native_source_dir).absolutePath
	
 
}

// TODO: check if we can use multiple threads and forward that to make/cmake
// make task:
task make(type:Exec) {
  
  inputs.dir file(native_build_dir).absolutePath

  workingDir native_build_dir
  
  if (Os.isFamily(Os.FAMILY_WINDOWS))
  {
	   
	executable project_root+'\\run_cmake_build.bat'
	//executable 'cmake.exe'
	//args '--build .'
	//args '--config Release'
	//args '--target ALL_BUILD'
	 
	outputs.file '.\\build\\cpp\\src\\libsqeazy.dll'
  } 
  else if (Os.isFamily(Os.FAMILY_MAC))
  {
    outputs.file './build/cpp/src/libsqeazy.dylib'
    def build_command = 'make'
    // if (org.gradle.workers.max > 1)
    //   build_command = 'make -j'+org.gradle.workers.max
    executable build_command
  } 
  else if (Os.isFamily(Os.FAMILY_UNIX))
  {
    outputs.file './build/cpp/src/libsqeazy.so'
    executable 'make'
  }

}

// TODO: check if we can use multiple threads and forward that to make/cmake
// make task:
task make_bundle(type:Exec) {
  
  inputs.dir file(native_build_dir).absolutePath

  workingDir native_build_dir
  
  if (Os.isFamily(Os.FAMILY_WINDOWS))
  {
    outputs.file './build/cpp/src/libsqeazy.dll'
    executable project_root+'\\run_cmake_bundle.bat'
	/* executable 'cmake.exe'
    args ' --build . --target bundle --config Release' */
  } 
  else if (Os.isFamily(Os.FAMILY_MAC))
  {
    outputs.file './build/cpp/src/libsqeazy.dylib'
    executable 'make'
    args 'bundle'

  } 
  else if (Os.isFamily(Os.FAMILY_UNIX))
  {
    outputs.file './build/cpp/src/libsqeazy.so'
    executable 'make'
    args 'bundle'
  }

}

task zip_bundle(type:Zip) {

def zinpath = file(native_build_dir).absolutePath+'/bundle'
  println ">> zip_bundle: "+zinpath+" .. "+file(native_build_dir).absolutePath
from (zinpath)
include 'lib*'
include '*h'
 // into 'resources' // note that this specifies path *in* the archive
 destinationDir file(native_build_dir+'/bundle') // directory that you want your archive to be placed in
 archiveName 'sqeazy_bundle.zip'

 def outputs_exp = file(native_build_dir+'/bundle/').absolutePath+archiveName
 outputs.files outputs_exp
}

task upload_bundle(type:Exec) {

     //curl -T <FILE.EXT> -upsteinb:<API_KEY> https://api.bintray.com/content/psteinb/sqeazy_binaries/<YOUR_COOL_PACKAGE_NAME>/<VERSION_NAME>/<FILE_TARGET_PATH>

   inputs.files zip_bundle.outputs.files
   def outputs_exp = file(native_build_dir+'/bundle/').absolutePath
   workingDir outputs_exp
   def arch = jnaerator_plat_path()

   if (Os.isFamily(Os.FAMILY_WINDOWS)) {
    inputs.files './src/cpp/inc/sqeazy.h', './build/cpp/bundle/libsqeazy.dll'
    executable 'curl.exe'
   } 
   else if (Os.isFamily(Os.FAMILY_MAC)) 
   {
     inputs.files './src/cpp/inc/sqeazy.h', './build/cpp/bundle/libsqeazy.dylib'
     executable 'curl'
   }
   else if (Os.isFamily(Os.FAMILY_UNIX)) 
   {
     inputs.files './src/cpp/inc/sqeazy.h', './build/cpp/bundle/libsqeazy.so'
     executable 'curl'
   }

   def fname = file(zip_bundle.outputs.files[0]).getName()
   args '-T'+fname,'-u'+bintray_user+':'+bintray_key, 'https://api.bintray.com/content/psteinb/sqeazy_binaries/'+arch+'/'+version+'/'+fname+'?publish=1';
   
   println '>> [upload_bundle] ' + executable + ' ' + args 

}

// Build java bindings:
task java_bindings(type:JavaExec) {

  if (Os.isFamily(Os.FAMILY_WINDOWS)) {
    inputs.files './src/cpp/inc/sqeazy.h', './build/cpp/src/libsqeazy.dll'
  } 
  else if (Os.isFamily(Os.FAMILY_MAC)) 
  {
    inputs.files './src/cpp/inc/sqeazy.h', './build/cpp/src/libsqeazy.dylib'}
  else if (Os.isFamily(Os.FAMILY_UNIX)) 
  {
    inputs.files './src/cpp/inc/sqeazy.h', './build/cpp/src/libsqeazy.so'
  }

  outputs.file 'src/java/src/sqeazy/bindings/SqeazyLibrary.java'

  workingDir '.'
  def arch = jnaerator_plat_path()


  File libsqeazy_file;
  File sqeazy_header;

  if (Os.isFamily(Os.FAMILY_WINDOWS)) {

    libsqeazy_file = file( native_build_dir + "/src/libsqeazy.dll" )
    sqeazy_header = file( native_source_dir + "/inc/sqeazy.h" )

  } 
  else if (Os.isFamily(Os.FAMILY_MAC)) 
  {

    libsqeazy_file = file( native_build_dir + "/src/libsqeazy.dylib" )
    sqeazy_header = file( native_source_dir + "/inc/sqeazy.h" )

  } 
  else if (Os.isFamily(Os.FAMILY_UNIX)) 
  {

    libsqeazy_file = file( native_build_dir + "/src/libsqeazy.so" )
    sqeazy_header = file( native_source_dir + "/inc/sqeazy.h" )

  }

  //see  https://github.com/mike-plummer/NativeGroovy/blob/master/build.gradle 
  description 'Execute JNAerator to auto-generate BridJ bindings'
  main = 'com.ochafik.lang.jnaerator.JNAerator'
  args '-library','sqeazy',
	'-f',
  	'-o','src/java/src',
	'-rootPackage','src',
  	'-package','sqeazy.bindings',
  	'-arch',arch,
  	'-libFile',libsqeazy_file.absolutePath,
  	'-runtime','BridJ',
  	'-mode','Directory',
  	//'-jar','src/java/sqeazy.jar',
  	sqeazy_header.absolutePath
  	
  
  classpath = files('tools/jnaerator.jar')
	
}

// make task:
task ctest(type:Exec) {
  
  inputs.dir file(native_build_dir).absolutePath
  workingDir native_build_dir
  
  if (Os.isFamily(Os.FAMILY_WINDOWS))
  {
    executable 'ctest.exe -C Release'
  } 
  else if (Os.isFamily(Os.FAMILY_MAC))
  {
    executable 'ctest'
  } 
  else if (Os.isFamily(Os.FAMILY_UNIX))
  {
    executable 'ctest'
  }

}

task build_native <<  {

  // if (Os.isFamily(Os.FAMILY_WINDOWS)) {
  //   inputs.files "./build/cpp/src/libsqeazy.dll"
  // } 
  // else if (Os.isFamily(Os.FAMILY_MAC))
  // {
  //   inputs.files "./build/cpp/src/libsqeazy.dylib"
  // }
  // else if (Os.isFamily(Os.FAMILY_UNIX))
  // {
  //   inputs.files "./build/cpp/src/libsqeazy.so"
  // }

  println 'sqeazy native build successful'
  
}

task sqeazy_available << {

  //todo: download files if they don't exist!
  
  println 'checking if native libraries are present ...'
  
  if (Os.isFamily(Os.FAMILY_WINDOWS))
  {
    assert file("./build/cpp/src/libsqeazy.dll").exists()
  } 
  else if (Os.isFamily(Os.FAMILY_MAC)) 
  {
    assert file("./build/cpp/src/libsqeazy.dylib").exists()
  }
  else if (Os.isFamily(Os.FAMILY_UNIX)) 
  {
    assert file("./build/cpp/src/libsqeazy.so").exists()
  }



  
}

// Task dependencies:

//native tasks
cmake.dependsOn create_build_dir
make.dependsOn cmake
ctest.dependsOn make
build_native.dependsOn ctest

make_bundle.dependsOn cmake
zip_bundle.dependsOn make_bundle
upload_bundle.dependsOn zip_bundle

//java tasks
java_bindings.dependsOn sqeazy_available
compileJava.dependsOn java_bindings
test.dependsOn compileJava


//***********************************************************************************
// JAVA CODE BUILDING

sourceSets
{
	main
	{
		java
		{ srcDir 'src/java/src' }
		resources
		{ srcDir 'src/java/src' }
	}
	test
	{
		java
		{ srcDir 'src/java/src' }
		resources
		{ srcDir 'src/java/src' }
	}
}

sourceCompatibility = 1.6

test
{
	testLogging.showStandardStreams = true
	testLogging
	{ events "passed", "skipped", "failed" }

	exclude '**/demo/**'
	exclude '**/run/**'

	maxHeapSize = "4G"
}

dependencies
{

  compile group: 'commons-collections', name: 'commons-collections', version: '3.2.1'
  compile group: 'commons-lang', name: 'commons-lang', version: '2.6'
  compile group: 'commons-io', name: 'commons-io', version: '2.4'
  compile group: 'org.apache.commons', name: 'commons-math3', version: '3.4.1'
  compile group: 'com.nativelibs4java', name: 'bridj', version: '0.7.0'
  compile group: 'junit', name: 'junit', version: '4.+'

  testCompile group: 'junit', name: 'junit', version: '4.+'
}

repositories
{
	mavenCentral()
	maven
	{ url "http://oss.sonatype.org/content/groups/public" }
	
}


task sourcesJar(type: Jar, dependsOn:classes) {
	classifier = 'sources'
	from sourceSets.main.allSource
}

task javadocJar(type: Jar, dependsOn:javadoc) {
	classifier = 'javadoc'
	from javadoc.destinationDir
}

if (JavaVersion.current().isJava8Compatible()) {
	allprojects {
		tasks.withType(Javadoc) {
			options.addStringOption('Xdoclint:none', '-quiet')
		}
	}
}

//***********************************************************************************
// PUBLISHING


group = 'net.sqeazy'

//TODO: infer version from git!


artifacts
{
	archives sourcesJar
	archives javadocJar
}

publishing {
	publications {
		SqeazyArtifacts(MavenPublication) {
			from components.java
			groupId group
			artifact sourcesJar { classifier "sources" }
			version '0.1' //same than above
		}
	}
}

if(hasProperty('bintray_user') && hasProperty('bintray_key') )
{
	bintray {

		// property must be set in ~/.gradle/gradle.properties
		user = bintray_user
		key =  bintray_key

		publications = ['SqeazyArtifacts'] //When uploading configuration files
		dryRun = false //Whether to run this as dry-run, without deploying
		publish = true //If version should be auto published after an upload
		pkg {
		  repo = 'maven'
		  userOrg = user //An optional organization name when the repo belongs to one of the user's orgs
		  name = 'sqeazy'
		  //desc = 'sqeazy'
		  websiteUrl = 'https://github.com/sqeazy/sqeazy'
		  issueTrackerUrl = 'https://github.com/sqeazy/sqeazy/issues'
		  vcsUrl = 'https://github.com/sqeazy/sqeazy.git'
		  licenses = ['LGPL-3.0']
		  labels = [
		    'compression',
		    'hardware',
		    'encoding',
		    'microscopy',
		    '3D',
		    'images'
		  ]
		  publicDownloadNumbers = true
		  //attributes= ['a': ['ay1', 'ay2'], 'b': ['bee'], c: 'cee'] //Optional package-level attributes
		  //Optional version descriptor
		  version {
		    name = project.version //Bintray logical version name
		    desc = '.'
		    released  = new java.util.Date()
		    vcsTag = project.version
		    /*attributes = ['gradle-plugin': 'com.use.less:com.use.less.gradle:gradle-useless-plugin'] //Optional version-level attributes
		      gpg {
		      sign = false //Determines whether to GPG sign the files. The default is false
		      passphrase = 'passphrase' //Optional. The passphrase for GPG signing'
		      }
		      mavenCentralSync {
		      sync = false //Optional (true by default). Determines whether to sync the version to Maven Central.
		      user = 'userToken' //OSS user token
		      password = 'paasword' //OSS user password
		      close = '1' //Optional property. By default the staging repository is closed and artifacts are released to Maven Central. You can optionally turn this behaviour off (by puting 0 as value) and release the version manually.
		      }  /**/          
		  }
		}
		/**/
	}
}











