package sqeazy.bindings;
import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.Pointer;
import org.bridj.ann.Library;
import org.bridj.ann.Ptr;
import org.bridj.ann.Runtime;
/**
 * Wrapper for library <b>sqeazy</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("sqeazy") 
@Runtime(CRuntime.class) 
public class SqeazyLibrary {
	static {
		BridJ.register();
	}
	/**
	 * SQY_RasterDiffEncode_3D_UI16 - Raster differencing scheme on 3D unsigned 16 bit int data.<br>
	 * Encoding: Each following voxel is visited in row major order and the difference between the current voxel<br>
	 * and the average of already visited neighboring voxels is computed and stored at the<br>
	 * corresponding location in the destination buffer. Boundary conditions: if a neighbor of a <br>
	 * voxel is outside of the volume, its value is assumed to be 0. For the first voxel, all neighbors<br>
	 * are outside of the volume and the average is thus 0.<br>
	 * width, height, depth 	: volume dimensions in voxels<br>
	 * src 					: row major 3D contiguous array of voxels (externally allocated)<br>
	 * dst 					: row major 3D contiguous array of voxels (externally allocated)<br>
	 * Returns 0 if success, another code if there was an error (error codes provided below)<br>
	 * extensions 1: if src==dst the function is capable of doing in-place processing.<br>
	 * Original signature : <code>int SQY_RasterDiffEncode_3D_UI16(int, int, int, const char*, char*)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:53</i>
	 */
	public static int SQY_RasterDiffEncode_3D_UI16(int width, int height, int depth, Pointer<Byte > src, Pointer<Byte > dst) {
		return SQY_RasterDiffEncode_3D_UI16(width, height, depth, Pointer.getPeer(src), Pointer.getPeer(dst));
	}
	protected native static int SQY_RasterDiffEncode_3D_UI16(int width, int height, int depth, @Ptr long src, @Ptr long dst);
	/**
	 * SQY_RasterDiffDecode_3D_UI16 - Raster differencing scheme on 3D unsigned 16 bit int data.<br>
	 * Decoding: Each voxel is visited in row major order. The voxel in the destination buffer at the<br>
	 * current location is computed as the sum of the average of the already decoded neighboring voxels<br>
	 * and the current difference value stored in the source buffer at the current location.<br>
	 * Boundary conditions: if a neighbor of a voxel is outside of the volume, its value is assumed to be 0.<br>
	 * For the first voxel, all neighbors are outside of the volume and the average is thus 0.<br>
	 * width, height, depth 	: volume dimensions in voxels<br>
	 * src 					: row major 3D contiguous array of voxels (externally allocated)<br>
	 * dst 					: row major 3D contiguous array of voxels (externally allocated)<br>
	 * Returns 0 if success, another code if there was an error (error codes provided below)<br>
	 * extensions 1: if src==dst the function is capable of doing in-place processing.<br>
	 * Original signature : <code>int SQY_RasterDiffDecode_3D_UI16(int, int, int, const char*, char*)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:72</i>
	 */
	public static int SQY_RasterDiffDecode_3D_UI16(int width, int height, int depth, Pointer<Byte > src, Pointer<Byte > dst) {
		return SQY_RasterDiffDecode_3D_UI16(width, height, depth, Pointer.getPeer(src), Pointer.getPeer(dst));
	}
	protected native static int SQY_RasterDiffDecode_3D_UI16(int width, int height, int depth, @Ptr long src, @Ptr long dst);
	/**
	 * SQY_BitSwap4Encode_UI16 - 4 Bit swapping scheme on unsigned 16 bit int data.<br>
	 * Encoding: Each 16 bit integer is split in four 4 bit parts: Ai, Bi, Ci, Di.<br>
	 * The destination buffer is filled with first all Ai, then all Bi, then all Ci, <br>
	 * then all Di. Thus the destination buffer has the same length as the source buffer.<br>
	 * src 					: contiguous array of voxels (externally allocated)<br>
	 * dst 					: contiguous array of voxels (externally allocated)<br>
	 * length 					: length of both buffers<br>
	 * Returns 0 if success, another code if there was an error (error codes provided below)<br>
	 * extensions 1: if src==dst the function is capable of doing in-place processing.<br>
	 * Original signature : <code>int SQY_BitSwap4Encode_UI16(const char*, char*, long)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:94</i>
	 */
	public static int SQY_BitSwap4Encode_UI16(Pointer<Byte > src, Pointer<Byte > dst, @org.bridj.ann.CLong long length) {
		return SQY_BitSwap4Encode_UI16(Pointer.getPeer(src), Pointer.getPeer(dst), length);
	}
	protected native static int SQY_BitSwap4Encode_UI16(@Ptr long src, @Ptr long dst, @org.bridj.ann.CLong long length);
	/**
	 * Original signature : <code>int SQY_BitSwap4Encode_I16(const char*, char*, long)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:95</i>
	 */
	public static int SQY_BitSwap4Encode_I16(Pointer<Byte > src, Pointer<Byte > dst, @org.bridj.ann.CLong long length) {
		return SQY_BitSwap4Encode_I16(Pointer.getPeer(src), Pointer.getPeer(dst), length);
	}
	protected native static int SQY_BitSwap4Encode_I16(@Ptr long src, @Ptr long dst, @org.bridj.ann.CLong long length);
	/**
	 * SQY_BitSwap4Decode_UI16 - 4 Bit swapping scheme on unsigned 16 bit int data.<br>
	 * Encoding: The permutation described above is inverted.<br>
	 * src 					: contiguous array of voxels (externally allocated)<br>
	 * dst 					: contiguous array of voxels (externally allocated)<br>
	 * length 					: length of both buffers<br>
	 * Returns 0 if success, another code if there was an error (error codes provided below)<br>
	 * extensions 1: if src==dst the function is capable of doing in-place processing.<br>
	 * Original signature : <code>int SQY_BitSwap4Decode_UI16(const char*, char*, long)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:110</i>
	 */
	public static int SQY_BitSwap4Decode_UI16(Pointer<Byte > src, Pointer<Byte > dst, @org.bridj.ann.CLong long length) {
		return SQY_BitSwap4Decode_UI16(Pointer.getPeer(src), Pointer.getPeer(dst), length);
	}
	protected native static int SQY_BitSwap4Decode_UI16(@Ptr long src, @Ptr long dst, @org.bridj.ann.CLong long length);
	/**
	 * Original signature : <code>int SQY_BitSwap4Decode_I16(const char*, char*, long)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:111</i>
	 */
	public static int SQY_BitSwap4Decode_I16(Pointer<Byte > src, Pointer<Byte > dst, @org.bridj.ann.CLong long length) {
		return SQY_BitSwap4Decode_I16(Pointer.getPeer(src), Pointer.getPeer(dst), length);
	}
	protected native static int SQY_BitSwap4Decode_I16(@Ptr long src, @Ptr long dst, @org.bridj.ann.CLong long length);
	/**
	 * SQY_BitSwap8Encode_UI16 - 8 Bit swapping scheme on unsigned 16 bit int data.<br>
	 * Encoding: Each 16 bit integer is split in two 8 bit parts: Ai, Bi.<br>
	 * The destination buffer is filled with first all Ai, then all Bi, <br>
	 * Thus the destination buffer has the same length as the source buffer.<br>
	 * src 					: contiguous array of voxels (externally allocated)<br>
	 * dst 					: contiguous array of voxels (externally allocated)<br>
	 * length 					: length of both buffers<br>
	 * Returns 0 if success, another code if there was an error (error codes provided below)<br>
	 * extensions 1: if src==dst the function is capable of doing in-place processing.<br>
	 * Original signature : <code>int SQY_BitSwap8Encode_UI16(const char*, char*, long)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:128</i>
	 */
	public static int SQY_BitSwap8Encode_UI16(Pointer<Byte > src, Pointer<Byte > dst, @org.bridj.ann.CLong long length) {
		return SQY_BitSwap8Encode_UI16(Pointer.getPeer(src), Pointer.getPeer(dst), length);
	}
	protected native static int SQY_BitSwap8Encode_UI16(@Ptr long src, @Ptr long dst, @org.bridj.ann.CLong long length);
	/**
	 * SQY_BitSwap8Decode_UI16 - 8 Bit swapping scheme on unsigned 16 bit int data.<br>
	 * Encoding: The permutation described above is inverted.<br>
	 * src 					: contiguous array of voxels (externally allocated)<br>
	 * dst 					: contiguous array of voxels (externally allocated)<br>
	 * length 					: length of both buffers<br>
	 * Returns 0 if success, another code if there was an error (error codes provided below)<br>
	 * extensions 1: if src==dst the function is capable of doing in-place processing.<br>
	 * Original signature : <code>int SQY_BitSwap8Decode_UI16(const char*, char*, long)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:143</i>
	 */
	public static int SQY_BitSwap8Decode_UI16(Pointer<Byte > src, Pointer<Byte > dst, @org.bridj.ann.CLong long length) {
		return SQY_BitSwap8Decode_UI16(Pointer.getPeer(src), Pointer.getPeer(dst), length);
	}
	protected native static int SQY_BitSwap8Decode_UI16(@Ptr long src, @Ptr long dst, @org.bridj.ann.CLong long length);
	/**
	 * Original signature : <code>int SQY_BitSwap8Encode_I16(const char*, char*, long)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:144</i>
	 */
	public static int SQY_BitSwap8Encode_I16(Pointer<Byte > src, Pointer<Byte > dst, @org.bridj.ann.CLong long length) {
		return SQY_BitSwap8Encode_I16(Pointer.getPeer(src), Pointer.getPeer(dst), length);
	}
	protected native static int SQY_BitSwap8Encode_I16(@Ptr long src, @Ptr long dst, @org.bridj.ann.CLong long length);
	/**
	 * Original signature : <code>int SQY_BitSwap8Decode_I16(const char*, char*, long)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:145</i>
	 */
	public static int SQY_BitSwap8Decode_I16(Pointer<Byte > src, Pointer<Byte > dst, @org.bridj.ann.CLong long length) {
		return SQY_BitSwap8Decode_I16(Pointer.getPeer(src), Pointer.getPeer(dst), length);
	}
	protected native static int SQY_BitSwap8Decode_I16(@Ptr long src, @Ptr long dst, @org.bridj.ann.CLong long length);
	/**
	 * Original signature : <code>int SQY_BitSwap2Encode_UI16(const char*, char*, long)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:148</i>
	 */
	public static int SQY_BitSwap2Encode_UI16(Pointer<Byte > src, Pointer<Byte > dst, @org.bridj.ann.CLong long length) {
		return SQY_BitSwap2Encode_UI16(Pointer.getPeer(src), Pointer.getPeer(dst), length);
	}
	protected native static int SQY_BitSwap2Encode_UI16(@Ptr long src, @Ptr long dst, @org.bridj.ann.CLong long length);
	/**
	 * Original signature : <code>int SQY_BitSwap2Decode_UI16(const char*, char*, long)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:149</i>
	 */
	public static int SQY_BitSwap2Decode_UI16(Pointer<Byte > src, Pointer<Byte > dst, @org.bridj.ann.CLong long length) {
		return SQY_BitSwap2Decode_UI16(Pointer.getPeer(src), Pointer.getPeer(dst), length);
	}
	protected native static int SQY_BitSwap2Decode_UI16(@Ptr long src, @Ptr long dst, @org.bridj.ann.CLong long length);
	/**
	 * Original signature : <code>int SQY_BitSwap2Encode_I16(const char*, char*, long)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:150</i>
	 */
	public static int SQY_BitSwap2Encode_I16(Pointer<Byte > src, Pointer<Byte > dst, @org.bridj.ann.CLong long length) {
		return SQY_BitSwap2Encode_I16(Pointer.getPeer(src), Pointer.getPeer(dst), length);
	}
	protected native static int SQY_BitSwap2Encode_I16(@Ptr long src, @Ptr long dst, @org.bridj.ann.CLong long length);
	/**
	 * Original signature : <code>int SQY_BitSwap2Decode_I16(const char*, char*, long)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:151</i>
	 */
	public static int SQY_BitSwap2Decode_I16(Pointer<Byte > src, Pointer<Byte > dst, @org.bridj.ann.CLong long length) {
		return SQY_BitSwap2Decode_I16(Pointer.getPeer(src), Pointer.getPeer(dst), length);
	}
	protected native static int SQY_BitSwap2Decode_I16(@Ptr long src, @Ptr long dst, @org.bridj.ann.CLong long length);
	/**
	 * Original signature : <code>int SQY_BitSwap1Encode_UI16(const char*, char*, long)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:153</i>
	 */
	public static int SQY_BitSwap1Encode_UI16(Pointer<Byte > src, Pointer<Byte > dst, @org.bridj.ann.CLong long length) {
		return SQY_BitSwap1Encode_UI16(Pointer.getPeer(src), Pointer.getPeer(dst), length);
	}
	protected native static int SQY_BitSwap1Encode_UI16(@Ptr long src, @Ptr long dst, @org.bridj.ann.CLong long length);
	/**
	 * Original signature : <code>int SQY_BitSwap1Decode_UI16(const char*, char*, long)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:154</i>
	 */
	public static int SQY_BitSwap1Decode_UI16(Pointer<Byte > src, Pointer<Byte > dst, @org.bridj.ann.CLong long length) {
		return SQY_BitSwap1Decode_UI16(Pointer.getPeer(src), Pointer.getPeer(dst), length);
	}
	protected native static int SQY_BitSwap1Decode_UI16(@Ptr long src, @Ptr long dst, @org.bridj.ann.CLong long length);
	/**
	 * Original signature : <code>int SQY_BitSwap1Encode_I16(const char*, char*, long)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:155</i>
	 */
	public static int SQY_BitSwap1Encode_I16(Pointer<Byte > src, Pointer<Byte > dst, @org.bridj.ann.CLong long length) {
		return SQY_BitSwap1Encode_I16(Pointer.getPeer(src), Pointer.getPeer(dst), length);
	}
	protected native static int SQY_BitSwap1Encode_I16(@Ptr long src, @Ptr long dst, @org.bridj.ann.CLong long length);
	/**
	 * Original signature : <code>int SQY_BitSwap1Decode_I16(const char*, char*, long)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:156</i>
	 */
	public static int SQY_BitSwap1Decode_I16(Pointer<Byte > src, Pointer<Byte > dst, @org.bridj.ann.CLong long length) {
		return SQY_BitSwap1Decode_I16(Pointer.getPeer(src), Pointer.getPeer(dst), length);
	}
	protected native static int SQY_BitSwap1Decode_I16(@Ptr long src, @Ptr long dst, @org.bridj.ann.CLong long length);
	/**
	 * SQY_RLEEncode_UI8 - 8 Bit Run length encoding scheme.<br>
	 * Encoding: The first 8 bytes represented an unsigned <br>
	 * a contiguous stretch of repeated bytes: i.e. XXXXXXX...X of length n<br>
	 * with n >= minrunlength is outputed as the byte sequence: <br>
	 * 1nX 	: where 1 indicates that integer n is encoded with 1 byte (unsigned).<br>
	 * this is in the case that n<256<br>
	 * 2nnX	: where	2 indicates that the integer n is encoded with 2 bytes (unsigned).<br>
	 * this is the case that  256<= n < 256*256	<br>
	 * 4nnnnX	: where	4 indicates that the integer n is encoded with 4 bytes (unsigned).<br>
	 * this is the case that  256*256<= n 		<br>
	 * Regions of length l (i.e.: 'XYZ...XYZ' )that are not repeated or with repetitions of length less than <br>
	 * minrunlength are simply copied to the destination buffer with a the following similar block structure:<br>
	 * OlXYZ...XYZ 	: where O (O=One=1) indicates that integer l is encoded with 1 byte (unsigned).<br>
	 * this is in the case that l<256<br>
	 * TllXYZ...XYZ 	: where	T (T=Two=2) indicates that the integer l is encoded with 2 bytes (unsigned).<br>
	 * this is the case that  256<= l < 256*256	<br>
	 * FllllXYZ...XYZ 	: where	F (F=Four=4) indicates that the integer l is encoded with 4 bytes (unsigned).<br>
	 * this is the case that  256*256<= l<br>
	 * The block headers 1n, 2nn, 4nnnn, Ol, Tll, Fllll  ensure that the output stream is made of blocks <br>
	 * of clearly defined lengths.<br>
	 * src 					: contiguous array of voxels (externally allocated)<br>
	 * dst 					: contiguous array of voxels (externally allocated)<br>
	 * length 					: length of both buffers<br>
	 * minrunlength			: minimal run length to encode<br>
	 * Returns 0 if success, another code if there was an error (error codes provided below)<br>
	 * extensions 1: if src==dst the function is capable of doing in-place processing.<br>
	 * Original signature : <code>int SQY_RLEEncode_UI8(const char*, char*, long, long)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:198</i>
	 */
	public static int SQY_RLEEncode_UI8(Pointer<Byte > src, Pointer<Byte > dst, @org.bridj.ann.CLong long length, @org.bridj.ann.CLong long minrunlength) {
		return SQY_RLEEncode_UI8(Pointer.getPeer(src), Pointer.getPeer(dst), length, minrunlength);
	}
	protected native static int SQY_RLEEncode_UI8(@Ptr long src, @Ptr long dst, @org.bridj.ann.CLong long length, @org.bridj.ann.CLong long minrunlength);
	/**
	 * SQY_RLEDecode_UI8 - 8 Bit Run length encoding scheme.<br>
	 * Decoding: The block stream described above is parsed and a decompressed stream of bytes<br>
	 * is appended to the output buffer.<br>
	 * src 					: contiguous array of voxels (externally allocated)<br>
	 * dst 					: contiguous array of voxels (externally allocated)<br>
	 * length 					: length of both buffers<br>
	 * minrunlength			: minimal run length to encode<br>
	 * Returns 0 if success, another code if there was an error (error codes provided below)<br>
	 * Original signature : <code>int SQY_RLEDecode_UI8(const char*, char*, long)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:214</i>
	 */
	public static int SQY_RLEDecode_UI8(Pointer<Byte > src, Pointer<Byte > dst, @org.bridj.ann.CLong long length) {
		return SQY_RLEDecode_UI8(Pointer.getPeer(src), Pointer.getPeer(dst), length);
	}
	protected native static int SQY_RLEDecode_UI8(@Ptr long src, @Ptr long dst, @org.bridj.ann.CLong long length);
	/**
	 * SQY_RmBackground_AtMode_UI16 - Subtract background from src <br>
	 * Given the mode M of all voxels, subtract M+epsilon from every voxel in src (clipping at 0). <br>
	 * If dst is 0, the operation is performed in-place.<br>
	 * src 					: contiguous array of voxels (externally allocated)<br>
	 * dst       				: contiguous array of voxels (externally allocated)<br>
	 * length 					: length of both buffers<br>
	 * epsilon					: epsilon to be provided by user<br>
	 * Returns 0 if success, another code if there was an error (error codes provided below)<br>
	 * Original signature : <code>int SQY_RmBackground_AtMode_UI16(char*, char*, long, unsigned short)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:232</i>
	 */
	public static int SQY_RmBackground_AtMode_UI16(Pointer<Byte > src, Pointer<Byte > dst, @org.bridj.ann.CLong long length, short epsilon) {
		return SQY_RmBackground_AtMode_UI16(Pointer.getPeer(src), Pointer.getPeer(dst), length, epsilon);
	}
	protected native static int SQY_RmBackground_AtMode_UI16(@Ptr long src, @Ptr long dst, @org.bridj.ann.CLong long length, short epsilon);
	/**
	 * SQY_RmBackground_Estimated_UI16 - Subtract background from src using an estimate of the noise<br>
	 * In order to allow an automated removal of the background, we assume that the shot noise locate <br>
	 * at the mode of the pixel value distribution is sampled from a Poisson PDF. Hence, the mode <br>
	 * (being the mean of the Poisson, aka lambda) and the variance of the Poisson (for a Poisson <br>
	 * PDF this equals lambda as well) are subtraced from every voxel in src (clipping at 0). If dst <br>
	 * is 0, the operation is performed in-place.<br>
	 * src 					: contiguous array of voxels (externally allocated)<br>
	 * dst       				: contiguous array of voxels (externally allocated)<br>
	 * width 					: width of the image stack as 16-bit integer<br>
	 * height 					: height of the image stack as 16-bit integer<br>
	 * depth 					: depth of the image stack as 16-bit integer<br>
	 * Returns 0 if success, another code if there was an error (error codes provided below)<br>
	 * Original signature : <code>int SQY_RmBackground_Estimated_UI16(int, int, int, char*, char*)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:252</i>
	 */
	public static int SQY_RmBackground_Estimated_UI16(int width, int height, int depth, Pointer<Byte > src, Pointer<Byte > dst) {
		return SQY_RmBackground_Estimated_UI16(width, height, depth, Pointer.getPeer(src), Pointer.getPeer(dst));
	}
	protected native static int SQY_RmBackground_Estimated_UI16(int width, int height, int depth, @Ptr long src, @Ptr long dst);
	/**
	 * SQY_LZ4Encode - Compress using LZ4.<br>
	 * Compresses the source buffer into the destination buffer using LZ4.<br>
	 * The destination buffer should be a bit larger than the source buffer<br>
	 * in case the compressed buffer requires more space. <br>
	 * The first 8 bytes of the destination buffer encode a 64 bit long that<br>
	 * represents the length of the source buffer.<br>
	 * src 					: contiguous array of voxels (externally allocated)<br>
	 * srclength 				: length in bytes of source buffer<br>
	 * dst 					: LZ4 compressed buffer (already allocated)<br>
	 * dstlength 				: length in bytes of externally allocated destination buffer (needs to give the length of dst in Bytes),<br>
	 * modified by function call to reflect the effective <br>
	 * compressed buffer length after the call.<br>
	 * Returns 0 if success, another code if there was an error (error codes provided below)<br>
	 * error 1 -  destination buffer is not large enough<br>
	 * Original signature : <code>int SQY_LZ4Encode(const char*, long, char*, long*)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:281</i>
	 */
	public static int SQY_LZ4Encode(Pointer<Byte > src, @org.bridj.ann.CLong long srclength, Pointer<Byte > dst, Pointer<org.bridj.CLong > dstlength) {
		return SQY_LZ4Encode(Pointer.getPeer(src), srclength, Pointer.getPeer(dst), Pointer.getPeer(dstlength));
	}
	protected native static int SQY_LZ4Encode(@Ptr long src, @org.bridj.ann.CLong long srclength, @Ptr long dst, @Ptr long dstlength);
	/**
	 * SQY_LZ4_Max_Compressed_Length - Calculates the maximum size of the output buffer from LZ4 compression<br>
	 * The first 8 bytes of the destination buffer encode a 64 bit long that<br>
	 * represents the length of the source buffer.<br>
	 * length 					: (in) length in bytes of decompressed buffer<br>
	 * (out) maximum length in bytes of compressed buffer<br>
	 * Returns 0 if success, another code if there was an error (error codes provided below)<br>
	 * Original signature : <code>int SQY_LZ4_Max_Compressed_Length(long*)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:296</i>
	 */
	public static int SQY_LZ4_Max_Compressed_Length(Pointer<org.bridj.CLong > length) {
		return SQY_LZ4_Max_Compressed_Length(Pointer.getPeer(length));
	}
	protected native static int SQY_LZ4_Max_Compressed_Length(@Ptr long length);
	/**
	 * SQY_LZ4_Decompressed_Length - Extracts the size of the decompressed buffer from the first 8 Byte of data<br>
	 * The first 8 bytes of the destination buffer encode a 64 bit long that<br>
	 * represents the length of the source buffer. This function extracts it.<br>
	 * data					: buffer to contain the compressed data as output by SQY_LZ4Encode<br>
	 * length					: (in) length in bytes of incoming data buffer<br>
	 * (out) extracted length in bytes of decompressed buffer to be output by SQY_LZ4Decode called on data<br>
	 * Returns 0 if success, another code if there was an error (error codes provided below)<br>
	 * Original signature : <code>int SQY_LZ4_Decompressed_Length(const char*, long*)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:311</i>
	 */
	public static int SQY_LZ4_Decompressed_Length(Pointer<Byte > data, Pointer<org.bridj.CLong > length) {
		return SQY_LZ4_Decompressed_Length(Pointer.getPeer(data), Pointer.getPeer(length));
	}
	protected native static int SQY_LZ4_Decompressed_Length(@Ptr long data, @Ptr long length);
	/**
	 * SQY_LZ4Decode - Decompress using LZ4.<br>
	 * Decompresses the source buffer into the destination buffer using LZ4.<br>
	 * The destination buffer should be allocated externally. The first 8 bytes of <br>
	 * the source buffer are not part of the LZ4 compressed buffer but indicate the<br>
	 * length of the original uncompressed buffer.<br>
	 * The necessary buffer length can be obtained by calling SQY_LZ4Length. <br>
	 * src 					: LZ4 compressed buffer (externally allocated)<br>
	 * srclength 				: length in bytes of compressed buffer<br>
	 * dst 					: contiguous array of voxels <br>
	 * (externally allocated, length from SQY_LZ4Length)<br>
	 * Returns 0 if success, another code if there was an error (error codes provided below)<br>
	 * Original signature : <code>int SQY_LZ4Decode(const char*, long, char*)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:330</i>
	 */
	public static int SQY_LZ4Decode(Pointer<Byte > src, @org.bridj.ann.CLong long srclength, Pointer<Byte > dst) {
		return SQY_LZ4Decode(Pointer.getPeer(src), srclength, Pointer.getPeer(dst));
	}
	protected native static int SQY_LZ4Decode(@Ptr long src, @org.bridj.ann.CLong long srclength, @Ptr long dst);
	/**
	 * Original signature : <code>int SQY_Header_Size(const char*, long*)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:332</i>
	 */
	public static int SQY_Header_Size(Pointer<Byte > src, Pointer<org.bridj.CLong > length) {
		return SQY_Header_Size(Pointer.getPeer(src), Pointer.getPeer(length));
	}
	protected native static int SQY_Header_Size(@Ptr long src, @Ptr long length);
	/**
	 * Original signature : <code>int SQY_Version_Triple(int*)</code><br>
	 * <i>native declaration : src/cpp/inc/sqeazy.h:334</i>
	 */
	public static int SQY_Version_Triple(Pointer<Integer > version) {
		return SQY_Version_Triple(Pointer.getPeer(version));
	}
	protected native static int SQY_Version_Triple(@Ptr long version);
}
